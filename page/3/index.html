<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fenicesun.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="fenice&#39;s blog">
<meta property="og:type" content="website">
<meta property="og:title" content="FENICE">
<meta property="og:url" content="https://fenicesun.com/page/3/index.html">
<meta property="og:site_name" content="FENICE">
<meta property="og:description" content="fenice&#39;s blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Fenice Sun">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://fenicesun.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>FENICE</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">FENICE</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Rock and opera fans</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://fenicesun.com/2015/09/07/introduction-to-epoll/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fenice Sun">
      <meta itemprop="description" content="fenice's blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FENICE">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2015/09/07/introduction-to-epoll/" class="post-title-link" itemprop="url">introduction to epoll</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2015-09-07 22:38:26" itemprop="dateCreated datePublished" datetime="2015-09-07T22:38:26+08:00">2015-09-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-03-08 13:54:32" itemprop="dateModified" datetime="2019-03-08T13:54:32+08:00">2019-03-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/programming/" itemprop="url" rel="index"><span itemprop="name">programming</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="epoll详解"><a href="#epoll详解" class="headerlink" title="epoll详解"></a>epoll详解</h3><br/>

<h4 id="为什么选择Epoll"><a href="#为什么选择Epoll" class="headerlink" title="为什么选择Epoll"></a>为什么选择Epoll</h4><ul>
<li>SELECT受描述符数量的限制，一般为1024或2048。而epoll的支持的描述符数量与机器内存大小相关，每1G内存可以支持10万左右的描述符数。</li>
<li>SELECT检查描述符上数据是否准备好需要通过轮询并用FD_ISSET检测整个描述符列表，而且检测报文到达的操作需要被频繁地调用，在并发连接数增加后性能会明显力不从心。相比SELECT，POLL也只是取消了最大监控文件描述符数量的限制，并没有从根本上解决SELECT存在的问题。<br/>

</li>
</ul>
<h4 id="epoll的基本使用"><a href="#epoll的基本使用" class="headerlink" title="epoll的基本使用"></a>epoll的基本使用</h4><h5 id="1-epfd文件描述符的创建"><a href="#1-epfd文件描述符的创建" class="headerlink" title="1. epfd文件描述符的创建"></a>1. epfd文件描述符的创建</h5><pre><code>#include &lt;sys/epoll.h&gt;
int epoll_create(int size);</code></pre>
<p> 早期的epoll实现中，对监控文件描述符的组织并不是红黑树，而是哈希表。这里的size实际已经没有意义。</p>
<h5 id="2-使用epoll-ctl注册监控的描述符和事件"><a href="#2-使用epoll-ctl注册监控的描述符和事件" class="headerlink" title="2. 使用epoll_ctl注册监控的描述符和事件"></a>2. 使用epoll_ctl注册监控的描述符和事件</h5><pre><code>#include &lt;sys/epoll.h&gt;
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</code></pre>
<p>函数说明：</p>
<ul>
<li><p>epfd: 由epoll_create创建的epoll描述符</p>
</li>
<li><p>op:   指定的操作类型</p>
<ul>
<li>EPOLL_CTL_ADD: 往事件表中注册fd上的事件</li>
<li>EPOLL_CTL_MOD: 修改fd上的注册事件</li>
<li>EPOLL_CTL_DEL: 删除fd上的注册事件</li>
</ul>
</li>
<li><p>event: 指定fd上的事件，它是epoll_event结构脂针类型</p>
<ul>
<li><p>epoll_event的定义：</p>
<pre><code>
    struct epoll_event &amp;#123;
        __unit32_t events;  //epoll event
        epoll_data_t data;  //user data
    &amp;#125;    </code></pre>
</li>
<li><p>events: 描述事件类型</p>
</li>
<li><p>data成员: 存储用户数据</p>
<pre><code>
    typedef union epoll_data &amp;#123;
        void* ptr;
        int fd;     //指定所属的目标文件描述符
        uint32_t u32;
        uint64_t u64;
    &amp;#125;</code></pre>
</li>
</ul>
</li>
</ul>
<h5 id="3-使用epoll-wait函数收集监听描述符的数据响应"><a href="#3-使用epoll-wait函数收集监听描述符的数据响应" class="headerlink" title="3. 使用epoll_wait函数收集监听描述符的数据响应"></a>3. 使用epoll_wait函数收集监听描述符的数据响应</h5><pre><code>#include &lt;sys/epoll.h&gt;
int epoll_wait(int epfd, struct epoll_event* events, int maxevents, int timeout);</code></pre>
<p>函数说明：</p>
<ul>
<li>返回值：成功时返回就绪的文件描述符的个数，失败时返回-1并设置errno</li>
<li>timeout: 指定epoll_wait的超时时间，单位为毫秒。若timeout=-1表示epoll_wait将永远阻塞，直到IO事件发生。当timeout=0时，epoll_wait调用将立即返回。当timeout为大于0的正数时，即为epoll_wait超时的毫秒数。</li>
<li>events: 这是一个用来返回的指针，将所有就绪事件从内核事件表拷贝到events指针所指向的数组中。</li>
<li>maxevents: 指定最多监听多少个事件。</li>
</ul>
<br/>

<h4 id="LT模式与ET模式"><a href="#LT模式与ET模式" class="headerlink" title="LT模式与ET模式"></a>LT模式与ET模式</h4><ul>
<li>LT（水平触发模式）：只要fd满足相应的读写条件（有数据没有处理）就通知给用户空间，将epitem加入rdlist，进程被唤醒，epoll_wait继续执行。LT模式只要有数据没有处理就会一直通知下去。event触发的情况：<ol>
<li>buffer中有数据可读的时候，即buffer不空的时候fd的event的可读就置1。</li>
<li>buffer中有空间可写的时候，即buffer不满的时候fd的event</li>
</ol>
</li>
<li>ET（边缘触发模式）：只有当fd的状态发生了改变，ep_poll_callback被调用。fd就绪只会被通知一次，而LT模式下只要满足读写条件就会返回就绪。如果使用ET模式，需要一直read/write到出错为止。导致fd状态改变：<ol>
<li>当buffer由不可读状态变为可读状态，即由空变为不空的时候。</li>
<li>当有新数据到达时，即buffer中的待读内容变多的时候。</li>
<li>当buffer由不可写状态变为可写状态，即由满变为不满的时候。</li>
<li>当旧有数据被发送走，即buffer中待写的内容变少的时候。</li>
</ol>
</li>
</ul>
<br/>

<h4 id="epoll处理网络连接框架"><a href="#epoll处理网络连接框架" class="headerlink" title="epoll处理网络连接框架"></a>epoll处理网络连接框架</h4><pre><code>for( ; ; )
    &amp;#123;
        nfds = epoll_wait(epfd,events,20,500);
        for(i=0;i&lt;nfds;++i)
        &amp;#123;
            if(events[i].data.fd==listenfd) //有新的连接
            &amp;#123;
                connfd = accept(listenfd,(sockaddr *)&amp;clientaddr, &amp;clilen); //accept这个连接
                ev.data.fd=connfd;
                ev.events=EPOLLIN|EPOLLET;
                epoll_ctl(epfd,EPOLL_CTL_ADD,connfd,&amp;ev); //将新的fd添加到epoll的监听队列中
            &amp;#125;
            else if( events[i].events&amp;EPOLLIN ) //接收到数据，读socket
            &amp;#123;
                n = read(sockfd, line, MAXLINE)) &lt; 0    //读
                ev.data.ptr = md;     //md为自定义类型，添加数据
                ev.events=EPOLLOUT|EPOLLET;
                epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev);//修改标识符，等待下一个循环时发送数据，异步处理的精髓
            &amp;#125;
            else if(events[i].events&amp;EPOLLOUT) //有数据待发送，写socket
            &amp;#123;
                struct myepoll_data* md = (myepoll_data*)events[i].data.ptr;    //取数据
                sockfd = md-&gt;fd;
                send( sockfd, md-&gt;ptr, strlen((char*)md-&gt;ptr), 0 );        //发送数据
                ev.data.fd=sockfd;
                ev.events=EPOLLIN|EPOLLET;
                epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev); //修改标识符，等待下一个循环时接收数据
            &amp;#125;
            else
            &amp;#123;
                //其他的处理
            &amp;#125;
        &amp;#125;
    &amp;#125;</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://fenicesun.com/2015/09/06/make-your-unix-crash-in-3-seconds/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fenice Sun">
      <meta itemprop="description" content="fenice's blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FENICE">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2015/09/06/make-your-unix-crash-in-3-seconds/" class="post-title-link" itemprop="url">make your unix crash in 3 seconds</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2015-09-06 22:42:18" itemprop="dateCreated datePublished" datetime="2015-09-06T22:42:18+08:00">2015-09-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-01-19 12:40:54" itemprop="dateModified" datetime="2019-01-19T12:40:54+08:00">2019-01-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/programming/" itemprop="url" rel="index"><span itemprop="name">programming</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="赶紧搞挂你的unix吧"><a href="#赶紧搞挂你的unix吧" class="headerlink" title="赶紧搞挂你的unix吧"></a>赶紧搞挂你的unix吧</h3><pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;


int
main(void) &amp;#123;

    pid_t pid;
    char *buf;
    for (;;) &amp;#123;
        if ((pid = fork()) &lt; 0) &amp;#123;
            printf(&quot;fork error\n&quot;);
        &amp;#125; else if (pid == 0) &amp;#123;
            buf = (char *)malloc(100000);
        &amp;#125; else &amp;#123;
            buf = (char *)malloc(200000);
        &amp;#125;
        buf = (char *)malloc(300000);
    &amp;#125;
    buf = (char *)malloc(500000);
    exit(0);
&amp;#125;

</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://fenicesun.com/2015/08/11/The-compile-steps-of-hello-c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fenice Sun">
      <meta itemprop="description" content="fenice's blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FENICE">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2015/08/11/The-compile-steps-of-hello-c/" class="post-title-link" itemprop="url">The compile steps of hello.c</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2015-08-11 18:29:07" itemprop="dateCreated datePublished" datetime="2015-08-11T18:29:07+08:00">2015-08-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-12 22:12:02" itemprop="dateModified" datetime="2020-02-12T22:12:02+08:00">2020-02-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/programming/" itemprop="url" rel="index"><span itemprop="name">programming</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="hello-c在编译过程中发生了什么"><a href="#hello-c在编译过程中发生了什么" class="headerlink" title="hello.c在编译过程中发生了什么"></a>hello.c在编译过程中发生了什么</h3><p>unix系统中，C程序通过编译器由一堆记录代码的文本文件(源文件)，最终被其他程序转化为一系列的低级机器语言指令，然后这些指令按照一种称为可执行目标程序的格式打包，并以二进制文件的形式存储在磁盘上。目标程序也称为可执行目标文件。</p>

<p>让我们看一看经典的hello.c</p>

<pre><code>#include &lt;stdio.h&gt;

int
main() &amp;#123;
    printf(&quot;Hello World\n&quot;);
    return 0;
&amp;#125;</code></pre>
<p>而从源文件到目标文件的转换是通过编译器驱动程序来完成，具体工具则是GNU项目里的gcc</p>

<blockquote>
<p>unix&gt; gcc -o hello hello.c</p>
</blockquote>
<p>在这里，GCC编译器读取源程序文件hello.c，并把它翻译成一个可执行目标文件hello。这个翻译过程分为四个阶段，如下图。（预处理器、编译器、汇编器和链接器）一起构成了编译系统(compilation system)</p>

<img src="compile_helloc.png" style="border:none;">

<ul>
<li>预处理阶段 <p>预处理器(cpp)根据以字符#开头的命令，修改原始的源程序，将include及define的实际源代码/数据对#指令进行文本替换，插入到程序文本中得到另一个c程序，以.i作为扩展名。</p>   </li>
<li>编译阶段 <p>编译器(ccl)将文本文件hello.i翻译成文本文件hello.s，这是一个汇编语言程序。汇编语言程序中每条语句都以一种标准的文本格式表述了一条低级机器语言指令。</p></li>
<li>汇编阶段 <p>汇编器(as)将hello.s翻译成机器语言指令，即0101...的二进制位码，并把这些指令打包成可重定向目标程序(relocatable object program)的格式，并将结果保存为目标文件hello.o。hello.o是一个二进制文件，他的字节编码是机器语言指令。</p></li>
<li>链接阶段 <p>连接器(ld)将hello.o目标文件与hello.c这个程序调用到的库函数目标文件进行合并，得到最终hello可执行文件。上面hello.c程序调用了c标准库里的printf函数，因此ld会将printf.o与我们的hello.o合并得到hello，这里的hello就是一个可执行目标文件(可执行文件)，可以被加载到内存中，由操作系统执行。</p></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://fenicesun.com/2015/02/07/segment-tree-of-time-series/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fenice Sun">
      <meta itemprop="description" content="fenice's blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FENICE">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2015/02/07/segment-tree-of-time-series/" class="post-title-link" itemprop="url">segment tree of time series</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2015-02-07 22:59:35" itemprop="dateCreated datePublished" datetime="2015-02-07T22:59:35+08:00">2015-02-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-01-19 12:48:52" itemprop="dateModified" datetime="2019-01-19T12:48:52+08:00">2019-01-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="日期序列线段树"><a href="#日期序列线段树" class="headerlink" title="日期序列线段树"></a>日期序列线段树</h3><blockquote>
<p>处理时间序列的区间可加性问题</p>
</blockquote>
<pre><code>&lt;?php

/**
 * Description: 时间序列线段树
 *
 */

define(&quot;INFINITE&quot;, pow(2, 64));

class TSSegTree &amp;#123;

    private $begin;
    private $end;
    private $segTree = array();
    private $delay_mark = array();

    public static $debug_count = 0;

    public function __construct($begin, $end, $init_arr=array()) &amp;#123;

        $this-&gt;begin = $begin;
        $this-&gt;end   = $end;
        $this-&gt;build(0, $this-&gt;begin, $this-&gt;end, $init_arr);
    &amp;#125;

    private function lchild($father) &amp;#123;
        return $father * 2 + 1;
    &amp;#125;

    private function rchild($father) &amp;#123;
        return $father * 2 + 2;
    &amp;#125;

    // 取两个日期的中间日期
    private function middate($begin, $end) &amp;#123;
        $interval = (strtotime($end)-strtotime($begin)) / 86400;
        $interval = intval($interval / 2);
        return $this-&gt;nextnday($begin, $interval);
    &amp;#125;

    private function nextnday($date, $n=1) &amp;#123;
        $operator = $n &gt;= 0? &#39;+&#39; : &#39;-&#39;;
        return date(&#39;Y-m-d&#39;, strtotime(&quot;&amp;#123;$date&amp;#125; &amp;#123;$operator&amp;#125;&amp;#123;$n&amp;#125; day&quot;));
    &amp;#125;

    // 更新当前节点值
    public function pushUp($root) &amp;#123;
        $lchild = $this-&gt;lchild($root);
        $rchild = $this-&gt;rchild($root);
        $this-&gt;segTree[$root] = min($this-&gt;segTree[$lchild], $this-&gt;segTree[$rchild]);
    &amp;#125;

    // 构建线段树
    public function build($root = 0, $begin, $end, $init_arr=array()) &amp;#123;

        $this-&gt;delay_mark[$root] = 0;
        if (strtotime($begin) == strtotime($end)) &amp;#123;
            $this-&gt;segTree[$root] = $init_arr[$begin];
        &amp;#125; else &amp;#123;
            $mid = $this-&gt;middate($begin, $end);
            $this-&gt;build($root * 2 + 1, $begin, $mid, $init_arr);
            $this-&gt;build($root * 2 + 2,  $this-&gt;nextnday($mid), $end, $init_arr);
            $this-&gt;pushUp($root);
        &amp;#125;
    &amp;#125;

    // 区间查询
    public function query($root, $nbegin, $nend, $qbegin, $qend) &amp;#123;

        if (strtotime($qbegin) &gt; strtotime($nend) ||
              strtotime($qend) &lt; strtotime($nbegin) ) &amp;#123;
                return INFINITE;
        &amp;#125;
        if (strtotime($qbegin) &lt;= strtotime($nbegin) &amp;&amp;
              strtotime($qend) &gt;= strtotime($nend) ) &amp;#123;
              return $this-&gt;segTree[$root];
        &amp;#125;
        $this-&gt;pushDown($root);
        $mid = $this-&gt;middate($nbegin, $nend);
        return min($this-&gt;query($this-&gt;lchild($root), $nbegin, $mid, $qbegin, $qend),
              $this-&gt;query($this-&gt;rchild($root), $this-&gt;nextnday($mid), $nend, $qbegin, $qend ));
    &amp;#125;

    // 单节点更新
    public function updateNode($root, $nbegin, $nend, $index, $val) &amp;#123;
        if (strtotime($nbegin) == strtotime($nend)) &amp;#123;
            if (strtotime($index) == strtotime($nbegin)) &amp;#123;
                $this-&gt;segTree[$root] += $val;
                // or other update method
            &amp;#125;
            return;
        &amp;#125;
        $mid = $this-&gt;middate($nbegin, $nend);
        if (strtotime($index) &lt;= strtotime($mid)) &amp;#123;
            $this-&gt;updateNode($this-&gt;lchild($root), $nbegin, $mid, $index, $val);
        &amp;#125; else &amp;#123;
            $this-&gt;updateNode($this-&gt;rchild($root), $this-&gt;nextnday($mid), $nend, $index, $val);
        &amp;#125;
        $this-&gt;pushUp($root);
        return;
    &amp;#125;

    // 向子节点更新标志域
    public function pushDown($root) &amp;#123;
        if ($this-&gt;delay_mark[$root] != 0) &amp;#123;
            $this-&gt;delay_mark[$this-&gt;lchild($root)] += $this-&gt;delay_mark[$root];
            $this-&gt;delay_mark[$this-&gt;rchild($root)] += $this-&gt;delay_mark[$root];
            // change value
            $this-&gt;segTree[$this-&gt;lchild($root)] += $this-&gt;delay_mark[$root];
            $this-&gt;segTree[$this-&gt;rchild($root)] += $this-&gt;delay_mark[$root];
            $this-&gt;delay_mark[$root] = 0;
        &amp;#125;
    &amp;#125;

    // 区间更新
    public function updateRange($root, $nbegin, $nend, $ubegin, $uend, $val) &amp;#123;
        if ($ubegin &gt; $nend || $uend &lt; $nbegin) &amp;#123;
            return;
        &amp;#125;
        if ($ubegin &lt;= $nbegin &amp;&amp; $uend &gt;= $nend) &amp;#123;
            $this-&gt;segTree[$root] += $val;
            $this-&gt;delay_mark[$root] += $val;
            return;
        &amp;#125;
        $this-&gt;pushDown($root);
        $mid = $this-&gt;middate($nbegin, $nend);
        $this-&gt;updateRange($this-&gt;lchild($root), $nbegin, $mid, $ubegin, $uend, $val);
        $this-&gt;updateRange($this-&gt;rchild($root), $this-&gt;nextnday($mid), $nend, $ubegin, $uend, $val);
        $this-&gt;pushUp($root);
    &amp;#125;

    // 输出值
    public function dumpTree($root, $begin, $end) &amp;#123;
        echo &quot;&amp;#123;$begin&amp;#125; ~ &amp;#123;$end&amp;#125; : root: &amp;#123;$root&amp;#125;, val: &amp;#123;$this-&gt;segTree[$root]&amp;#125; &quot;;
        echo &quot;\r\n&quot;;
        if (strtotime($begin) == strtotime($end)) &amp;#123;
            return;
        &amp;#125; else &amp;#123;
            $mid = $this-&gt;middate($begin, $end);
            $this-&gt;dumpTree($this-&gt;lchild($root), $begin, $mid);
            $this-&gt;dumpTree($this-&gt;rchild($root), $this-&gt;nextnday($mid), $end);
        &amp;#125;
        return;
    &amp;#125;


&amp;#125;


function test() &amp;#123;
    $dataset = array(
        &#39;2017-01-01&#39; =&gt; 6,
        &#39;2017-01-02&#39; =&gt; 2,
        &#39;2017-01-03&#39; =&gt; 5,
        &#39;2017-01-04&#39; =&gt; 8,
        &#39;2017-01-05&#39; =&gt; 12,
        &#39;2017-01-06&#39; =&gt; 9,
        &#39;2017-01-07&#39; =&gt; 10,
        &#39;2017-01-08&#39; =&gt; 11
    );
    $tree = new TSSegTree(&#39;2017-01-01&#39;, &#39;2017-01-08&#39;, $dataset);
    $tree-&gt;updateNode(0, &#39;2017-01-01&#39;, &#39;2017-01-08&#39;, &#39;2017-01-04&#39;, 2);
    $result = $tree-&gt;query(0, &#39;2017-01-01&#39;, &#39;2017-01-08&#39;, &#39;2017-01-03&#39;, &#39;2017-01-06&#39;);
    echo $result;

    $tree-&gt;dumpTree(0, &#39;2017-01-01&#39;, &#39;2017-01-08&#39;);
    $tree-&gt;updateRange(0, &#39;2017-01-01&#39;, &#39;2017-01-08&#39;, &#39;2017-01-03&#39;, &#39;2017-01-06&#39;, -1);
    $result = $tree-&gt;query(0, &#39;2017-01-01&#39;, &#39;2017-01-08&#39;, &#39;2017-01-03&#39;, &#39;2017-01-06&#39;);
    echo $result;
    echo &quot;\r\n&quot;;
    $tree-&gt;dumpTree(0, &#39;2017-01-01&#39;, &#39;2017-01-08&#39;);

&amp;#125;
test();

?&gt;

</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://fenicesun.com/2014/09/25/proper-tail-call/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fenice Sun">
      <meta itemprop="description" content="fenice's blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FENICE">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2014/09/25/proper-tail-call/" class="post-title-link" itemprop="url">proper tail call</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2014-09-25 19:49:23" itemprop="dateCreated datePublished" datetime="2014-09-25T19:49:23+08:00">2014-09-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-01-19 12:47:53" itemprop="dateModified" datetime="2019-01-19T12:47:53+08:00">2019-01-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/programming/" itemprop="url" rel="index"><span itemprop="name">programming</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="正确的尾调用"><a href="#正确的尾调用" class="headerlink" title="正确的尾调用"></a>正确的尾调用</h3><br/>


<h4 id="什么是尾递归"><a href="#什么是尾递归" class="headerlink" title="什么是尾递归"></a>什么是尾递归</h4><p>所谓“尾调用”（tail call）就是一种类似goto的函数调用。当一个函数调用是另一个函数的最后一个动作时，该调用才算是一条“尾调用”。举例来说，以下代码对g的调用就是一条尾调用：</p>

<blockquote>
<p>function f(x) return g(x) end</p>
</blockquote>
<p>也就是说，当f调用完g之后就再无其他事情可做了。因此这种情况下，程序就不需要反悔那个“尾调用”所在的函数了。所以在尾调用之后，程序也不需要保存任何关于该函数的栈（stack）信息。当g返回时，执行控制权可以直接返回到调用f的那个点上。有一些编辑器的优化实现可以得益于这个特点，使得在进行尾调用时不耗费任何栈空间。将这种视线称为支持“尾调用消除”。</p>

<p>由于“尾调用”不会耗费栈空间，所以一个程序可以拥有无数嵌套的尾调用。举例来说，在调用以下函数时，传入任何数字作为参数都不会造成栈溢出：</p>

<pre><code> function foo(n)
     if n &gt; 0 then
         return foo(n-1)
   end
 end</code></pre>
<p>有一点需要注意的是，当想要受益于尾调用消除时，务必要确定当前的调用是“尾调用”。判断的标准是“一个函数在调用完另一个函数之后，是否就无其他事情需要做了”。有一些看似是尾调用的代码，其实都违背了这条准则。举例来说，以下的代码对g的调用就不是一条尾调用：</p>

<blockquote>
<p>function f(x) g(x) end</p>
</blockquote>
<p>这个示例的问题在于，当调用完g之后，    g并不能立即返回，它还需丢弃g返回的临时结果。类似的，以下的所有调用也不符合以上准则：</p>

<blockquote>
<p>return g(x) + 1         ——  必须做一次加法</p>
</blockquote>
<blockquote>
<p>return x or g(x)        ——  必须调整为一个返回值</p>
</blockquote>
<blockquote>
<p>return (g(x))           ——  必须调整为一个返回值</p>
</blockquote>
<p>只有<code>return &lt;func&gt;(&lt;args&gt;)</code> 这样的调用形式才算是一条尾调用。尾调用不一定要出现在函数尾部，只要是最后一步操作即可：</p>
<pre><code>function f(x) &amp;#123;
    if (x &gt; 0)
        return m(x)
    return n(x);
&amp;#125;</code></pre>
<h4 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h4><p>尾调用之所以和其他调用不同，就在于它的调用位置。尾递归由于是函数的最后一步操作，所以不需要保存外部函数的调用记录，因为调用位置，内部分配的栈信息都不会再用到，只要返回内层的调用记录，取代外层的调用结果。例如这个阶乘的递归计算：</p>

<p>code1:</p>
<pre><code>unsigned long fact(int n) &amp;#123;
    if (n == 1) 
        return 1;
    return n * fact(n - 1);
&amp;#125;</code></pre>
<p>code2:</p>
<pre><code>unsigned long fact(unsigned long cur, int n) &amp;#123;
    if (n == 1) 
        return cur;
    return fact(cur * n, n - 1);
&amp;#125;</code></pre>
<p>code1中，每次fact计算完成都需要返回调用它的函数中完成＊ n的操作，而code2中每次计算的结果作为参数进行尾递归传递，并不需要再向上返回，也不需要保持所调用它的函数的栈信息。在第n次调用fact之后直接返回了结果。</p>

<p>这就叫做尾递归优化，即只保留内层函数的调用记录。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用记录只有一项，这将大大节省内存。不会因为每一层的系统调用占据太多栈空间而造成栈溢出。</p>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://fenicesun.com/2014/06/20/heapsort-and-priority-queue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fenice Sun">
      <meta itemprop="description" content="fenice's blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FENICE">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2014/06/20/heapsort-and-priority-queue/" class="post-title-link" itemprop="url">heapsort and priority queue</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2014-06-20 23:38:59" itemprop="dateCreated datePublished" datetime="2014-06-20T23:38:59+08:00">2014-06-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2017-02-21 23:47:23" itemprop="dateModified" datetime="2017-02-21T23:47:23+08:00">2017-02-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="堆排序和优先级队列"><a href="#堆排序和优先级队列" class="headerlink" title="堆排序和优先级队列"></a>堆排序和优先级队列</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://fenicesun.com/2014/06/15/quick-sort-and-how-to-find-kth-number-in-sequence/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fenice Sun">
      <meta itemprop="description" content="fenice's blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FENICE">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2014/06/15/quick-sort-and-how-to-find-kth-number-in-sequence/" class="post-title-link" itemprop="url">quick sort and how to find kth number in sequence</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2014-06-15 23:14:36" itemprop="dateCreated datePublished" datetime="2014-06-15T23:14:36+08:00">2014-06-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-01-19 12:51:16" itemprop="dateModified" datetime="2019-01-19T12:51:16+08:00">2019-01-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="快速排序与寻找序列中的第k个线性统计量"><a href="#快速排序与寻找序列中的第k个线性统计量" class="headerlink" title="快速排序与寻找序列中的第k个线性统计量"></a>快速排序与寻找序列中的第k个线性统计量</h3><blockquote>
<p>快速排序（quick sort）基于二分（分治方法）的原地排序算法，算法平均复杂度O(lgn)具有非常优秀的性能，通常情况优于合并排序(merge sort)和堆排序(heap sort)。其中的线形划分操作可以看作冒泡排序中冒泡操作的一种改进，且具有很多其他的应用。</p>
</blockquote>
<p>和前面文章中介绍过的<a href="http://fenicesun.com/2014/05/30/merge-sort-and-the-number-of-inversions/">合并排序</a>类似, 快速排序也是基于分治法的处理策略。其基本思想是，通过一轮的线性划分和元素交换将待排序序列A[p..r]划分成A[p..q-1], A[q], A[q+1..r]三部分，并保证A[p..q-1]中任意元素 &lt;= A[q] &lt;= A[q+1..r]中任意元素（假设升序）,然后分别对子序列A[p..q-1]及A[q+1..r]进行线性划分, 直到序列为单个元素（必定有序）。排序的过程中，由于已经划分开的元素不需要进行比较，故减少了比较次数，降低了排序时间。</p>
<h4 id="分治法框架描述"><a href="#分治法框架描述" class="headerlink" title="分治法框架描述"></a>分治法框架描述</h4><p>1.分解（divide）: 将数组A[p..r]划分成两个（可能空）子数组A[p..q-1]和A[q+1..r]，使得A[p..q-1]中的每个元素都小于等于A[q]，而且小于等于A[q+1..r]中的元素。下标q也在划分的过程中进行计算。<br>2.解决（conquer）: 递归调用快速排序，对子数组A[p..q-1]和A[p+1..r]进行排序。<br>3.合并（merge）: 由于两个子序列是原地排序，故不需要合并操作。</p>
<p>下面是快速排序的过程：</p>
<pre><code>#include &lt;functional&gt;

template &lt;typename T&gt;
class Sorter
&amp;#123;
    static void QuickSort(T array[], int low, int high, const std::function&lt;int(T, T)&gt; &amp;cmp);
    static int hoare_partition(T array[], int low, int high, const std::function&lt;int(T, T)&gt; &amp;cmp);
    static int partition(T array[], int low, int high, const std::function&lt;int(T, T)&gt; &amp;cmp);
    static void Swap(T *a, T *b);
    static T SelectIth(T array[], int low, int high, int index, const std::function&lt;int(T, T)&gt; &amp;cmp);
&amp;#125;;

template &lt;typename T&gt;
void Sorter&lt;T&gt;::QuickSort(T *array, int low, int high, const std::function&lt;int(T, T)&gt; &amp;cmp) &amp;#123;
    if (low &lt; high) &amp;#123;
        int mid = partition(array, low, high, cmp);
        QuickSort(array, low, mid - 1, cmp);
        QuickSort(array, mid + 1, high, cmp);
    &amp;#125;
&amp;#125;</code></pre>
<p>若排序一个完整数组，最初调用过程为Sorter<Type>::QuickSort(A, 0, (sizeof(A)/sizeof(Type) - 1);</p>
<h4 id="线性划分"><a href="#线性划分" class="headerlink" title="线性划分"></a>线性划分</h4><p>快速排序最关键的算法就是PARTITION操作，他可以对数组A[p..r]进行就地重拍。PARTITION操作有多种算法，下面介绍最初的Hoare划分和算法导论中的优化版本。</p>
<h5 id="Hoare划分"><a href="#Hoare划分" class="headerlink" title="Hoare划分"></a>Hoare划分</h5><p>快速排序的算法思想由C.A.R.Hoare提出，并给出了一个最初版本的划分方法，据说改进自冒泡操作。代码如下：</p>
<pre><code>template &lt;typename T&gt;
int Sorter&lt;T&gt;::hoare_partition(T *array, int low, int high, const std::function&lt;int(T, T)&gt; &amp;cmp) &amp;#123;
    int left = low, right = high;
    T x = array[left];
    while (left &lt; right) &amp;#123;
        while (left &lt; right &amp;&amp; cmp(x, array[right])) &amp;#123;
            right--;
        &amp;#125;
        if (left &lt; right) &amp;#123;
            array[left] = array[right];
            left++;
        &amp;#125;
        while (left &lt; right &amp;&amp; !cmp(x, array[left])) &amp;#123;
            left++;
        &amp;#125;
        if (left &lt; right) &amp;#123;
            array[right] = array[left];
            right--;
        &amp;#125;
    &amp;#125;
    array[left] = x;
    return left;
&amp;#125;</code></pre>
<p>下面来分析上面这段代码，假设排序为升序<br>1、 维护两个指针，left指向序列的低位，right指向序列的高位。选取序列的最低位元素为主元（pivot）。<br>2、 right指针／游标从高位向低位移动，直到遇到第一个比主元小的元素，然后把当前元素赋值给left指针所指向的位置；left指针／游标从低位向高位移动，直到遇到第一个比主元大的元素，然后把当前元素赋值给right指针所指向的元素。<br>3、 按上述方式不断进行，直到left游标和right游标相遇，此时将主元填入left=right的位置。</p>
<p>Hoare-partition过程结束后，A[p..q-1]中的每个元素都小于等于A[q+1..r]中的每一个元素。Hoare-partition方法又滋生出很多变种，都是减少划分过程中的比较次数，这里不展开讲述。</p>
<h5 id="优化版本"><a href="#优化版本" class="headerlink" title="优化版本"></a>优化版本</h5><p>再到后来，N.Lomuto又提出了一种优化版本的划分方法，它现在写在算法导论一书中，C++代码如下：</p>
<pre><code>template &lt;typename T&gt;
int Sorter&lt;T&gt;::partition(T *array, int low, int high, const std::function&lt;int(T, T)&gt; &amp;cmp) &amp;#123;
    T x = array[high];
    int i = low - 1;
    for (int j = low; j &lt; high; j++) &amp;#123;
        if (cmp(array[j], x)) &amp;#123;
            i++;
            Swap(&amp;array[i], &amp;array[j]);
        &amp;#125;
    &amp;#125;
    Swap(&amp;array[i + 1], &amp;array[high]);
    return i + 1;
&amp;#125;</code></pre>
<p>这段代码是不是比hoare的版本简洁明了多了？ 不仅简短，而且更高效。<br>下面详细描述N.Momuto的PARTITION划分过程</p>
<p>PARTITION总是选择一个主元T x = array[high]，并围绕它来划分序列A[p..r]。随着该过程的开始，序列将被划分成四个区域。具体每一步变化过程如下：</p>
<pre><code>   i p,j                 r
  |2  8  7  1  3  5  6| 4

   p,i  j                r
  |2| 8  7  1  3  5  6| 4

   p,i    j              r
  |2| 8| 7  1  3  5  6| 4

   p,i       j           r
  |2| 8  7| 1  3  5  6| 4

   p  i         j        r
  |2| 1| 7  8| 3  5  6| 4

   p     i        j      r
  |2| 1  3| 8  7| 5  6| 4 

   p     i            j  r
  |2| 1  3| 8  7  5| 6| 4

   p     i               r
  |2| 1  3| 8  7  5  6| 4

   p     i               r
   2  1  3 |4| 7  5  6  8 |</code></pre>
<p>简而言之，跟hoare划分一样维护两个游标，但是从同一断开时向另一端移动，j每次移动时都比较array[j]和主元，如果比主元小，就将array[j]与array[i]的下一个元素进行置换，并移动i游标。<br>在上述代码的循环不定式中，对于任何数组下标k，都有</p>
<ol>
<li>如果p&lt;= k &lt;= i，则A[k] &lt;= x</li>
<li>如果i+1 &lt;= k &lt;= j-1，则A[k]    &gt; x</li>
<li>如果k=r，则A[k] = x</li>
</ol>
<p>PARTITION操作作用于数组A[p..r]得到四个区域，A[p..i]各元素都小于等于x，A[i+1..j-1]中的值都大于x，A[r] = x，A[j..r-1]中的值可以取任何值。</p>
<h4 id="快速排序的时间复杂度"><a href="#快速排序的时间复杂度" class="headerlink" title="快速排序的时间复杂度"></a>快速排序的时间复杂度</h4><p>当基数值不能很好地分割数组，即基准值将数组分成一个子数组中有一个记录，而另一个子组组有 n -1 个记录时，下一次的子数组只比原来数组小 1，这是快速排序的最差的情况。如果这种情况发生在每次划分过程中，那么快速排序就退化成了冒泡排序，其时间复杂度为O(n2)。</p>
<p>　　如果基准值都能讲数组分成相等的两部分，则出现快速排序的最佳情况。在这种情况下，我们还要对每个大小约为 n/2 的两个子数组进行排序。在一个大小为 n 的记录中确定一个记录的位置所需要的时间为O(n)。若T(n)为对n个记录进行排序所需要的时间，则每当一个记录得到其正确位置，整组大致分成两个相等的两部分时，我们得到快速排序算法的最佳时间复杂性。</p>
<p>　　T(n) &lt;= cn + 2T(n/2)    c是一个常数</p>
<p>　　　　　&lt;= cn + 2(cn/2+2T(n/4)) = 2cn+ 4T(n/4)</p>
<p>　　　　　&lt;= 2cn + 4(cn/4+ 2T(n/8)) = 3cn + 8T(n/8)</p>
<p>　　　　　　…… ……</p>
<p>　　　　　&lt;= cnlogn + nT(1) = O(nlogn)      其中cn 是一次划分所用的时间，c是一个常数</p>
<p>　　最坏的情况，每次划分都得到一个子序列，时间复杂度为：</p>
<p>　　T(n) = cn + T(n-1)</p>
<p>　　　　 = cn + c(n-1) + T(n - 2) = 2cn -c + T(n-2)</p>
<pre><code>    = 2cn -c + c(n - 2) + T(n-3) = 3cn -3c + T(n-3)</code></pre>
<p>　　　　……</p>
<p>　　　　 = c[n(n+1)/2-1] + T(1) =  O(n2)</p>
<p>　　快速排序的时间复杂度在平均情况下介于最佳与最差情况之间，假设每一次分割时，基准值处于最终排序好的位置的概率是一样的，基准值将数组分成长度为0 和 n-1，1 和 n-2，……的概率都是 1/n。在这种假设下，快速排序的平均时间复杂性为：</p>
<p>　　　　T(n) = cn + 1/n(T(k)+ T(n-k-1))   T(0) = c, T(1) = c</p>
<p>　　这是一个递推公式，T(k)和T(n-k-1)是指处理长度为 k 和 n-k-1 数组是快速排序算法所花费的时间， 根据公式所推算出来的时间为 O(nlogn)。因此快速排序的平均时间复杂性为O(nlogn)。</p>
<p>　　快速排序需要栈空间来实现递归，如果数组按局等方式被分割时，则最大的递归深度为 log n，需要的栈空间为 O(log n)。最坏的情况下在递归的每一级上，数组分割成长度为0的左子数组和长度为 n - 1 的右数组。这种情况下，递归的深度就成为 n，需要的栈空间为 O(n)。</p>
<p>　　因为快速排序在进行交换时，只是根据比较基数值判断是否交换，且不是相邻元素来交换，在交换过程中可能改变相同元素的顺序，因此是一种不稳定的排序算法。</p>
<h4 id="第i个线性统计量（寻找序列中第i大的数）"><a href="#第i个线性统计量（寻找序列中第i大的数）" class="headerlink" title="第i个线性统计量（寻找序列中第i大的数）"></a>第i个线性统计量（寻找序列中第i大的数）</h4><p>在一个由n个元素组成的序列中，第i个线性统计量是符合该序列的第i个元素，其实也就是求序列顺序的第i大／小的元素。形式化地定义这个问题：</p>
<ul>
<li>Input: 一个包含n个元素的序列A和一个数i， 1 &lt;= i &lt;= n</li>
<li>Output: 元素x(属于A)，恰好大于A中的i-1个元素。</li>
</ul>
<p>解决这问题的方法有很多</p>
<ol>
<li>朴素方法</li>
<li>先对序列进行排序，取第i个元素</li>
<li>维护一个二叉堆，弹出前i-1个元素</li>
</ol>
<p>这些方法都过于复杂，有没有更好的方法呢？<br>当然了，联想上面快速排序的PARTITION操作，马上就有灵感了。<br>在PARTITION操作中，序列A[p..r]被划分成A[p..q-1]，A[q]，A[q+1..r]，且有：<br>A[r..r]中任意元素&lt;= A[q] &lt;= A[q+1..r]，那么我们可以得出结论，对序列A[p..r]划分后，第q个线性统计量一定是A[q]。<br>假设我们要求的是第i个线性统计量，可以由分治法想到：<br>如果i==q，那么A[q]就是第i个线性统计量；<br>如果i &lt; q，可以在A[p..q-1]中寻找第i个线性统计量；<br>如果i &gt; q, 即在A[q+1..r]中寻找第i-（q+1-p）个线性统计量；</p>
<p>由上面可以写出代码：</p>
<pre><code>template &lt;typename T&gt;
T Sorter&lt;T&gt;::SelectIth(T *array, int low, int high, int index, const std::function&lt;int(T, T)&gt; &amp;cmp) &amp;#123;
    if (low == high)
        return array[low];
    int mid = partition(array, low, high, cmp);
    int k = mid - low + 1;
    if (index == k) &amp;#123;
        return array[mid];
    &amp;#125; else if (index &lt; k) &amp;#123;
        return SelectIth(array, low, mid - 1, index, cmp);
    &amp;#125; else &amp;#123;
        return SelectIth(array, mid + 1, high, index - k, cmp);
    &amp;#125;
&amp;#125;</code></pre>
<p>这样就解决了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://fenicesun.com/2014/05/30/merge-sort-and-the-number-of-inversions/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fenice Sun">
      <meta itemprop="description" content="fenice's blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FENICE">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2014/05/30/merge-sort-and-the-number-of-inversions/" class="post-title-link" itemprop="url">merge sort and the number of inversions</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2014-05-30 22:18:42" itemprop="dateCreated datePublished" datetime="2014-05-30T22:18:42+08:00">2014-05-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-01-19 12:52:18" itemprop="dateModified" datetime="2019-01-19T12:52:18+08:00">2019-01-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="归并排序和逆序数"><a href="#归并排序和逆序数" class="headerlink" title="归并排序和逆序数"></a>归并排序和逆序数</h3><blockquote>
<p>分治法(Divide and conquer)是一种常用的算法策略，而归并排序就是基于分治思想的一种高效排序方法。基于分而治之的策略可以高效解决很多可分割的问题，比如求序列的逆序数。<br><br/></p>
</blockquote>
<h4 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h4><p><strong>思想：</strong><br>    将一个规模较大的问题（原问题）划分成n个规模较小而结构与原问题相似的子问题，递归地解决这些子问题，将子问题解的结果合并处理得到原问题的解。</p>
<p><strong>解决步骤：</strong> </p>
<ol>
<li>分解（divide):   将原问题分解成一系列相同结构的子问题</li>
<li>解决（conquer):  递归解决子问题。如果子问题足够小，直接求解</li>
<li>合并 (combine):  合并子问题的解</li>
</ol>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p><strong>解决方法：</strong>（按照分治的解决步骤）</p>
<ul>
<li>divide:  将待排序序列递归地二分分割成子序列，直到子序列长度为1</li>
<li>conquer:  对子序列分别进行归并排序</li>
<li>combine:  将两个已排序序列合并成一个统一的已排序序列</li>
</ul>
<p><strong>若对子序列排序时，长度为1时为递归边界。数组中仅含有一个元素时数组必定有序。</strong></p>
<p><strong>时间复杂度分析：</strong></p>
<p>分治法中，一个输入规模为n的序列实例，被划分成两个规模为n/b的问题，其中a个实例是需要求解的，假设n为b的幂，则有：</p>
<blockquote>
<p>T(n) = a T(n/b) + f(n)</p>
</blockquote>
<p>f(n)表示将a个子问题合并所需要的复杂度。那么在归并排序中，二分地递归分割，合并的时间复杂度为O(n), 则有</p>
<blockquote>
<p>T(n) = 2 * T(n/2) + O(n) </p>
</blockquote>
<p>规模为n的序列的划分后递归树高度为lg(n), 每轮合并复杂度O(n), 总复杂度近似为O(nlgn)</p>
<p>排序过程如图：<br/><br><img src="../../../../img/mergesort.png" alt="process"></p>
<p>废话少说，上代码</p>
<pre><code>//
// Created by fenice sun on 12/1/2017.
//

#ifndef ALGORITHM_SORTER_H
#define ALGORITHM_SORTER_H

#include &lt;functional&gt;

template &lt;typename T&gt;
class Sorter
&amp;#123;
public:
    static void MergeSort(T array[], int begin, int end, const std::function&lt;int(T, T)&gt; &amp;cmp);
    static void Merge(T array[], int p, int q, int r, const std::function&lt;int(T, T)&gt; &amp;cmp);
&amp;#125;;

template &lt;typename T&gt;
void Sorter&lt;T&gt;::Merge(T *array, int low, int mid, int high, const std::function&lt;int(T, T)&gt; &amp;cmp) &amp;#123;
    T * temp = new T[high - low + 1];
    int i = low, j = mid + 1;
    int k = 0;

    while (i &lt;= mid &amp;&amp; j &lt;= high) &amp;#123;
        if (cmp(array[i], array[j])) &amp;#123;
            temp[k++] = array[i++];
        &amp;#125; else &amp;#123;
            temp[k++] = array[j++];
        &amp;#125;
    &amp;#125;
    while (i &lt;= mid) &amp;#123;
        temp[k++] = array[i++];
    &amp;#125;
    while (j &lt;= high) &amp;#123;
        temp[k++] = array[j++];
    &amp;#125;
    for (int r = 0; r &lt; high - low + 1; ++r) &amp;#123;
        array[low + r] = temp[r];
    &amp;#125;
    delete [] temp;
&amp;#125;

template &lt;typename T&gt;
void Sorter&lt;T&gt;::MergeSort(T *array, int begin, int end, const std::function&lt;int(T, T)&gt; &amp;cmp) &amp;#123;
    if (begin &lt; end) &amp;#123;
        int mid = (begin + end) / 2;
        MergeSort(array, begin, mid, cmp);
        MergeSort(array, mid + 1, end, cmp);
        Merge(array, begin, mid, end, cmp);
    &amp;#125;
&amp;#125;


#endif //ALGORITHM_SORTER_H
</code></pre>
<h4 id="归并过程"><a href="#归并过程" class="headerlink" title="归并过程"></a>归并过程</h4><p>上面的归并排序代码是一个很经典的分治法处理框架，MergeSort中将序列分割成前后两段子序列，然后递归地处理前后两段序列。这里分解和处理的操作在不同的分治问题中大体相同，（参考快速排序）而排序的核心算法就是归并操作Merge。</p>
<p>对两个有序序列进行归并的时候，可以看作对两摞有序的扑克牌进行归并，每轮依次选取两摞牌中最上面牌的最小／最大的那张，把选出来的牌放进新的序列。直到有一摞牌被拿完，这时再把未拿完的牌全部放进新的序列，完成归并操作。 而对有序数组进行二路归并的时候，先让游标i = j = 0, 同理每次选取两个数组当前游标对应下标最小／最大的那个值，然后将游标做自增操作，直到某个数组的值被全部放进新的序列，最后再将另一个数组的值放进新序列，最后的新序列一定是有序的，可以证明。而归并的过程也使整个排序过程十分稳定。</p>
<p>在对两个有序序列进行归并的过程中，由于要创建一个新的序列，因此在排序过程中会有一些额外的空间开销。</p>
<h4 id="求序列的逆序对数量"><a href="#求序列的逆序对数量" class="headerlink" title="求序列的逆序对数量"></a>求序列的逆序对数量</h4><p><strong>逆序数定义：</strong></p>
<blockquote>
<p>对于一个序列中的n个元素，先规定各元素中有一个标准次序（例如n个不同的自然数，可规定从小到大为标准次序），于是在这n个元素中的任一排列，当某个排列的先后次序与标准次序不同时，就说有一个逆序。一个排列中的逆序对总数叫做这个排列的逆序数。</p>
</blockquote>
<p><strong>求解方法</strong></p>
<p><em>朴素方法</em><br>    <br/><br>    枚举序列中的所有任意两个元素的排列，如果有逆序，则计数。枚举序列中的任意两个元素，时间复杂度为O(n^2)。</p>
<p><strong>那么还有更好的方法吗？</strong></p>
<p>当然有了，让我们回顾归并排序中的归并过程。举个例子，在合并两个有序数组（升序）<br>var left = [2, 4, 5] 和 var right = [1, 3, 6]的过程中，首先由于left数组有序，所以无逆序数，那么逆序数的出现只可能在right数组中，令i = j = 0， 第一轮的比较中left[i] &gt; right[i]（2 &gt; 1）, 并不符合升序，而left又全部有序，因此right[1]=1小于所有的left数组中的元素,这样由right中的元素1就导致了序列中有了3个逆序数，以此类推，right[2]导致了序列中有2个逆序数，right[3]符合升序，导致了0个逆序数。因此序列的逆序数总个数为3 + 2 = 5。</p>
<p>让我们来修改归并排序代码：</p>
<pre><code>//
// Created by fenice sun on 12/1/2017.
//

#ifndef ALGORITHM_SORTER_H
#define ALGORITHM_SORTER_H

#include &lt;functional&gt;

template &lt;typename T&gt;
class Sorter
&amp;#123;
public:
    static int inversion_count;
public:
    static void MergeSort(T array[], int begin, int end, const std::function&lt;int(T, T)&gt; &amp;cmp);
    static void Merge(T array[], int p, int q, int r, const std::function&lt;int(T, T)&gt; &amp;cmp);
&amp;#125;;

template &lt;typename T&gt;
void Sorter&lt;T&gt;::Merge(T *array, int low, int mid, int high, const std::function&lt;int(T, T)&gt; &amp;cmp) &amp;#123;
    T * temp = new T[high - low + 1];
    int i = low, j = mid + 1;
    int k = 0;

    while (i &lt;= mid &amp;&amp; j &lt;= high) &amp;#123;
        if (cmp(array[i], array[j])) &amp;#123;
            temp[k++] = array[i++];
        &amp;#125; else &amp;#123;
            temp[k++] = array[j++];
            inversion_count += (mid - i + 1);
            //count
        &amp;#125;
    &amp;#125;
    while (i &lt;= mid) &amp;#123;
        temp[k++] = array[i++];
    &amp;#125;
    while (j &lt;= high) &amp;#123;
        temp[k++] = array[j++];
    &amp;#125;
    for (int r = 0; r &lt; high - low + 1; ++r) &amp;#123;
        array[low + r] = temp[r];
    &amp;#125;
    delete [] temp;
&amp;#125;

template &lt;typename T&gt;
void Sorter&lt;T&gt;::MergeSort(T *array, int begin, int end, const std::function&lt;int(T, T)&gt; &amp;cmp) &amp;#123;
    if (begin &lt; end) &amp;#123;
        int mid = (begin + end) / 2;
        MergeSort(array, begin, mid, cmp);
        MergeSort(array, mid + 1, end, cmp);
        Merge(array, begin, mid, end, cmp);
    &amp;#125;
&amp;#125;


#endif //ALGORITHM_SORTER_H
</code></pre>
<p>加入了一个inversion_count静态变量用来统计逆序数的数量，在归并的过程中加入一行代码</p>
<blockquote>
<p>inversion_count += (mid - i + 1);</p>
</blockquote>
<p>对当前的逆序数进行计算，right当前游标指向的元素对应的逆序数为left序列中游标指向的当前元素及其右边的所有元素个数 mid - i + 1。那么我们现在就以归并排序O(lgn)的时间复杂度算出了序列的逆序数个数。远好于朴素方法的O(n^2)。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://fenicesun.com/2014/05/05/native-sorting-algorithms/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fenice Sun">
      <meta itemprop="description" content="fenice's blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FENICE">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2014/05/05/native-sorting-algorithms/" class="post-title-link" itemprop="url">native sorting algorithms</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2014-05-05 23:16:38" itemprop="dateCreated datePublished" datetime="2014-05-05T23:16:38+08:00">2014-05-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-01-19 12:53:01" itemprop="dateModified" datetime="2019-01-19T12:53:01+08:00">2019-01-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="朴素排序方法"><a href="#朴素排序方法" class="headerlink" title="朴素排序方法"></a>朴素排序方法</h3><blockquote>
<p>排序和搜索是程序设计中最常用的算法，他们看似作用简单，却都闪现着经典算法的智慧与光芒。</p>
</blockquote>
<p>排序算法的形式化定义：</p>
<blockquote>
<ul>
<li>Input: n个数的序列：a1, a2, a3, …, an</li>
</ul>
</blockquote>
<ul>
<li>Output: n个数的排列：a1’, a2’, a3’, …, an’</li>
</ul>
<p>排序算法有很多种的分类方式，比如按数据存储形式分为内部排序和外部排序，按算法稳定性分为稳定排序和不稳定排序，按元素交换方式又分为插入排序、选择排序和交换排序等。<br>这里我根据排序算法不同的算法复杂度和算法思想将排序算法分为朴素排序、分治排序和复杂排序。</p>
<p>这里作者定义平均复杂度&gt;= O(n^2)的排序方法为朴素排序，下面重点介绍冒泡排序、选择排序、插入排序这三种方法，用尽量本质的语言来描述他们的思想, 并给出C++代码。<br>朴素排序都是将序列分为已排序区和未排序区，通过不断地从未排序区筛选比较出最大／最小的元素，将其加入到已排序区中。最终未排序区为空时，整个序列达到有序。</p>
<p>先给出三种排序方法的申明：</p>
<pre><code>#ifndef ALGORITHM_SORTER_H
#define ALGORITHM_SORTER_H

#include &lt;functional&gt;

template &lt;typename T&gt;
class Sorter
&amp;#123;
public:
    static void BubbleSort(T array[], int length, const std::function&lt;int(T, T)&gt; &amp;cmp);
    static void SelectSort(T array[], int length, const std::function&lt;int(T, T)&gt; &amp;cmp);
    static void InsertSort(T array[], int length, const std::function&lt;int(T, T)&gt; &amp;cmp);
    static void Swap(T *a, T *b);
&amp;#125;;</code></pre>
<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>特点：stable, in-place<br>思想：不停地将未排序区中的元素从高位向低位进行两两相邻元素的比较，将较大／较小元素进行交换，最终将当前未排序区中的最大／最小元素置换到已排序区中，直到未排序区为空。<br>平均复杂度：O(n^2)<br>最坏复杂度：O(n^2)<br>实现：两层循环不变式迭代，进行length-1趟冒泡，每趟冒泡将length ~ i +1之间的元素两两比较交换，将最大／最小的元素冒泡出来。</p>
<pre><code>template &lt;typename T&gt;
void Sorter&lt;T&gt;::BubbleSort(T *array, int length, const std::function&lt;int(T, T)&gt; &amp;cmp) &amp;#123;
    for (int i = 0; i &lt; length; i++) &amp;#123;
        for (int j = length; j &gt;= i + 1; j--) &amp;#123;
            if (cmp(array[j], array[j - 1])) &amp;#123;
                Swap(&amp;array[j], &amp;array[j - 1]);
            &amp;#125;
        &amp;#125;
    &amp;#125;
&amp;#125;</code></pre>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>特点：In-place, unstable<br>思想：不停地从未排序区中选择一个最大／最小的元素，并将这个元素与未排序区中的第一个元素交换，将其加入已排序区，迭代直至未排序区为空。<br>平均复杂度：O(n^2)<br>最坏复杂度：O(n^2)<br>实现：两轮循环不变式迭代，每次选择j+1~length之间最小／最大的元素与第j个元素交换，直至j = length-1</p>
<pre><code>template &lt;typename T&gt;
void Sorter&lt;T&gt;::SelectSort(T *array, int length, const std::function&lt;int(T, T)&gt; &amp;cmp) &amp;#123;
    for (int j = 0; j &lt; length; j++) &amp;#123;
        int index = j;
        for (int i = j + 1; i &lt; length; i++) &amp;#123;
            if (cmp(array[i], array[index])) &amp;#123;
                index = i;
            &amp;#125;
        &amp;#125;
        if (index != j) &amp;#123;
            Swap(&amp;array[index], &amp;array[j]);
        &amp;#125;
    &amp;#125;
&amp;#125;</code></pre>
<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p>特点：stable，in-place<br>思想：每次将未排序区中的第一个元素插入到已排序区中的合适位置，直到未排序区为空<br>平均复杂度：O(n^2)<br>最坏复杂度：O(n^2)<br>实现：两轮循环不定式迭代，每次将移动array[i]到array[i+1]腾出空间将array[j]插入到前面合适的位置</p>
<pre><code>template &lt;typename T&gt;
void Sorter&lt;T&gt;::InsertSort(T *array, int length, const std::function&lt;int(T, T)&gt; &amp;cmp) &amp;#123;
    for(int j = 1; j &lt; length; j++) &amp;#123;
        T key = array[j];
        int i = j - 1;
        while (i &gt;= 0 &amp;&amp; cmp(key, array[i]) ) &amp;#123;
            array[i + 1] = array[i];
            i--;
        &amp;#125;
        array[i + 1] = key;
    &amp;#125;
&amp;#125;</code></pre>
<p>上面的三种朴素的排序方法分别用了不同的未排序区选择与比较策略，不停地将未排序区选出的元素移动，加入到已排序区中。虽然思想上各不相同，却又有异曲同工之妙，这或许就是“朴素”的力量吧</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://fenicesun.com/2013/09/16/The-silent-night-in-shanghai/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fenice Sun">
      <meta itemprop="description" content="fenice's blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FENICE">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2013/09/16/The-silent-night-in-shanghai/" class="post-title-link" itemprop="url">The silent night in shanghai</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2013-09-16 21:18:01" itemprop="dateCreated datePublished" datetime="2013-09-16T21:18:01+08:00">2013-09-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-01 21:58:16" itemprop="dateModified" datetime="2020-03-01T21:58:16+08:00">2020-03-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/diary/" itemprop="url" rel="index"><span itemprop="name">diary</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="魔都的夜晚静悄悄"><a href="#魔都的夜晚静悄悄" class="headerlink" title="魔都的夜晚静悄悄"></a>魔都的夜晚静悄悄</h3><br/>


<p>那天到魔都的时候正好是周末，人多的令人激动。</p>

<p>这也许正是大都市的魅力，在二线三线城市的时候没法感觉的。</p>

<p>由于下午要提早去浦东机场接zxy，中午就先去预定的酒店办入住。从南京路边上的小巷转出去，穿过北京东路和苏州路一带，一直到厦门路。没想到上海也有这么老旧狭窄却热闹非凡的地方，路上是一家接着一家的店，店门口的人忙碌地装卸和清点货物，买者行色匆匆，卖着也应接不暇。突然间好喜欢这种场景，也许是想起了童年时代，那时还没有什么物流，父亲每隔几周就要去市区进货，也是这种似曾相识的店面里，向老板订货，等货托运过来然后清点付钱，最后找三轮车把货物运到车站搬上车回家。只是那些记忆早已模糊不堪，也许是我更喜欢这种烟火气的景象：每个人都在为了生存而打拼和努力，拼命的挣脱和向上，即使命途多舛也绝不低头认输。</p>

<p>在去浦东机场的地铁上看到了海，依稀能看到一望无际的海平面，就像年少影视剧记忆里的一样宽阔和无边无际。在海天相接的地方，仿佛就有精彩又未知的新世界，它是那么的近，又是那么的远。进的仿佛跳出地铁就能走过去，远的又好像是另一个不真实的世界。对于从小县城走出来的我来说，虽然不是第一次感受这些，却在每每看到这些景象的时候好像感受到了童年时的幻想与它的不真实。</p>

 <p>下午和zxy登上国际金融中心的顶层，眺望整个陆家嘴。整个初中时代所看过的那些杂志的背景仿佛都找到了出处，它满足了所有我曾经记忆中的高楼大厦以及各种现代化的形象。但是走在陆家嘴的路上却又感觉不到一点真实，毕竟这里没有生活的痕迹，没有我整个少年时代小县城里菜市场的吵闹和低矮住宅小区的归属感和拥有感。在这里，我不知道也无法去弄清楚这里属于谁，谁拥有这里。或许时谁都不属于这里，谁也不曾拥有它，它是所有人心中的现代化的影像。</p>

 <p>黄浦江的前半夜注定不是平凡的。它仿佛是个风姿绰约的中年妇女或是某个已经成为经典的女明星，所有人都会被她吸引过来一睹她的芳荣，而所有人都注定无法拥有她。晚风吹起女人们的长发，就像是她们偶像的吻，让人陶醉流连忘返。我和zxy依着外滩的栏杆，望着浦东陆家嘴的闪耀星光，那仿佛是一个新走红的女星，冷艳美丽而无法接近，却又雄心勃勃地要替代江那边的半老徐娘。我们谈人生，谈理想，谈未来，我说以后有了钱要在江对岸买层楼，zxy说好想以后去那里找份工作，我说我有了钱要包养你，zxy微微一笑了说好。年轻女人总是过于现实，而年轻的男人往往又过于不切实际，也许这是为什么女人往往都不属于同年纪的男人。</p>

<p>晚上回宾馆的时候已经很晚了。白天热闹非凡的北京东路那里已经完全没有人影，所有的店铺都关了门，好像这里一直都没有热闹过，就像是盖茨比的别墅。尽管我知道等明天第一缕阳光出来，这里就会恢复昨日的繁华，然而一切都感觉那么不真实，好像我从来没有来过一样。沿着苏州路往回走，一直没有见到人影。也许他们都回家休息去了，或者说，他们和我们一样，从来都不属于这里。他们也无法日夜拥有这里的精彩，就像谁会永远拥有一个电影明星呢。</p>

<p>可是尽管这样，我们还是要努力去证明我们的存在，以至于在年迈回乡之时，能在菜市场回忆往事时能不至于无话可说。然而我们也知道，尽管我们穷尽毕生的努力，也无法让她的白天为我们而寂静，夜晚为我们而欢闹。即使日后我们带着成功来到这里，在这样的夜晚也只能走在这条静悄悄的街道。</p>

<p>晚安魔都的夜。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Fenice Sun</p>
  <div class="site-description" itemprop="description">fenice's blog</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fenice Sun</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
